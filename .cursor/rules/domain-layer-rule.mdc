---
description: 도메인 레이어 작성 가이드
globs: 
alwaysApply: false
---
클린 아키텍처 기반 Domain 레이어 (Repository & UseCase) 가이드라인
Domain 레이어는 클린 아키텍처의 핵심으로, 애플리케이션의 순수한 비즈니스 로직과 규칙을 담고 있습니다. 이 레이어는 다른 어떤 레이어(UI, Data, Framework)에도 의존하지 않아야 하며, 애플리케이션의 가장 안정적인 부분이 됩니다. 이 가이드라인은 Domain 레이어의 주요 구성 요소인 Repository 인터페이스와 UseCase를 효과적으로 작성하는 데 도움을 줍니다.

핵심 원칙:

독립성 (Independence): Domain 레이어는 UI, Data, Infrastructure 레이어로부터 완전히 독립적이어야 합니다. 외부 변화에 영향을 받지 않아야 합니다.

비즈니스 로직 중심: 애플리케이션의 핵심 비즈니스 규칙, 정책, 절차를 포함합니다.

플랫폼 독립성: 특정 프레임워크나 라이브러리에 대한 의존성을 가지지 않습니다. 순수한 Kotlin/Java 코드로 작성되어야 합니다.

가이드라인 상세:

1. Repository 인터페이스 정의:

인터페이스 우선 정의: 데이터 접근을 위한 명세로 인터페이스를 먼저 Domain 레이어에 정의합니다.

구현은 Data 레이어: 실제 데이터 소스와 상호작용하는 Repository의 구현체는 Data 레이어에 위치합니다. 이는 Domain 레이어가 Data 레이어의 구체적인 구현 기술(e.g., Room, Retrofit)에 의존하지 않도록 합니다 (의존성 역전 원칙 - DIP).

역할: 데이터 소스(DB, 네트워크 등)에 대한 접근 방법을 추상화합니다. UseCase가 데이터 자체에 대해 신경 쓰지 않고 필요한 데이터 작업을 요청할 수 있도록 명세를 제공합니다.

메서드 정의: 비즈니스 로직(UseCase) 관점에서 필요한 데이터 오퍼레이션을 정의합니다. 데이터가 어떻게 저장되고 검색되는지에 대한 세부 사항을 노출하지 않습니다.

예시: getUserById(id: String): User?, saveProduct(product: Product): Result<Unit>, getRecentOrders(limit: Int): List<Order>

반환 타입: Domain 레이어에 정의된 Domain Model (Entity) 또는 기본(primitive) 타입을 사용해야 합니다. Data 레이어의 DTO(Data Transfer Object)나 특정 DB 모델을 직접 반환해서는 안 됩니다. 비동기 작업의 경우 suspend 함수를 사용할 수 있습니다.

명명 규칙: 관리하는 데이터의 종류를 명확히 나타내는 이름을 사용합니다 (e.g., UserRepository, ProductRepository, OrderRepository).

Hilt 주입 (@Binds): Hilt를 사용하여 의존성을 주입할 때는, Data 레이어의 Repository 구현체를 Domain 레이어의 Repository 인터페이스에 바인딩하기 위해 Hilt 모듈 내에서 @Binds 어노테이션을 사용하는 것이 일반적입니다. 이를 통해 UseCase 등에서는 인터페이스 타입으로 Repository를 주입받을 수 있습니다.

// Domain Layer
package com.example.domain.repository

import com.example.domain.model.User

interface UserRepository {
    suspend fun getUser(userId: String): User?
    suspend fun getAllUsers(): List<User>
    suspend fun saveUser(user: User): Result<Unit> // Result 래퍼 사용 예시
    suspend fun deleteUser(userId: String): Result<Unit>
}

// Data Layer (Hilt Module 예시)
/*
@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {

    @Binds
    @Singleton
    abstract fun bindUserRepository(
        userRepositoryImpl: UserRepositoryImpl
    ): UserRepository
}
*/

2. UseCase (Interactor) 정의:

역할: 애플리케이션의 개별 사용 사례(Use Case) 또는 비즈니스 상호작용을 캡슐화합니다. 특정 작업을 수행하기 위한 단계를 조정하고 비즈니스 규칙을 적용합니다. ViewModel은 이 UseCase를 호출하여 작업을 수행합니다.

인터페이스/구현체 패턴 (선택적): UseCase 역시 인터페이스를 먼저 정의하고 구현체를 만드는 패턴을 적용할 수 있습니다. 이는 특히 UseCase의 구현이 복잡하거나, 테스트 시 Mocking이 용이하게 하거나, 여러 구현을 가질 가능성이 있을 때 유용합니다.

단일 책임 원칙 (SRP): 각 UseCase(또는 그 구현체)는 하나의 명확하고 구체적인 비즈니스 작업(Action) 또는 쿼리(Query)를 나타내야 합니다. 너무 많은 책임을 가지지 않도록 작게 유지합니다.

명명 규칙: 수행하는 작업을 명확히 나타내는 동사구 형태로 이름을 짓습니다. 일반적으로 Verb + Noun + UseCase 형식을 따릅니다 (e.g., LoginUserUseCase, GetProductDetailsUseCase, SubmitOrderUseCase, ValidateEmailFormatUseCase). 인터페이스를 사용한다면 구현체는 UseCaseNameImpl 과 같이 명명할 수 있습니다.

의존성 (Hilt 생성자 주입): 필요한 Repository 인터페이스(들)는 **Hilt를 통해 생성자 주입(Constructor Injection)**으로 받습니다. UseCase 구현체의 생성자에 @Inject 어노테이션을 사용합니다.

Hilt 주입 (@Binds, 인터페이스 사용 시): UseCase에 인터페이스를 정의했다면, Repository와 마찬가지로 Hilt 모듈에서 @Binds를 사용하여 인터페이스와 구현체를 바인딩할 수 있습니다. 인터페이스 없이 구체 클래스만 사용한다면 @Binds는 필요하지 않습니다.

실행 메서드: 일반적으로 단일 public 메서드를 노출하여 UseCase를 실행합니다. Kotlin에서는 operator fun invoke를 사용하여 UseCase 객체(또는 구현체)를 함수처럼 호출할 수 있게 만드는 것이 일반적입니다.

// Domain Layer - UseCase 인터페이스 (선택적)
interface GetUserProfileUseCase {
   suspend operator fun invoke(userId: String): Result<UserProfile>
}

// Domain Layer - UseCase 구현체
class GetUserProfileUseCaseImpl @Inject constructor(
    private val userRepository: UserRepository,
    private val preferenceRepository: PreferenceRepository // 여러 Repository 주입 가능
) : GetUserProfileUseCase {
    override suspend operator fun invoke(userId: String): Result<UserProfile> {
        val user = userRepository.getUser(userId) ?: return Result.failure(UserNotFoundException())
        val preferences = preferenceRepository.getPreferencesForUser(userId)
        // ... 비즈니스 규칙 적용 ...
        val userProfile = UserProfile(user, preferences)
        return Result.success(userProfile)
    }
}

// Domain Layer (Hilt Module 예시 - UseCase 인터페이스 사용 시)
/*
@Module
@InstallIn(ViewModelComponent::class) // UseCase는 보통 ViewModel 스코프에 바인딩
abstract class UseCaseModule {

    @Binds
    abstract fun bindGetUserProfileUseCase(
        getUserProfileUseCaseImpl: GetUserProfileUseCaseImpl
    ): GetUserProfileUseCase
}
*/

입력/출력: 필요한 파라미터를 받아서 작업을 수행하고, 결과를 반환합니다. 반환 타입은 Domain Model, 기본 타입, 또는 작업 성공/실패와 데이터를 함께 캡슐화하는 Result 래퍼 클래스 등이 될 수 있습니다.

플랫폼 독립성: 안드로이드 SDK나 특정 프레임워크 클래스에 대한 의존성이 전혀 없어야 합니다. 순수 Kotlin/Java로만 작성되어야 테스트가 용이합니다.

오케스트레이션: 하나의 비즈니스 트랜잭션이 여러 Repository와의 상호작용을 필요로 할 때, UseCase는 이러한 상호작용을 조율(Orchestrate)하는 역할을 합니다.

3. Domain Model (Entity) 정의:

역할: 핵심 비즈니스 개념을 나타내는 데이터 구조입니다. 애플리케이션의 가장 중요한 정보(e.g., User, Product, Order)를 담습니다.

순수성: 데이터와 해당 데이터에 대한 필수적인 검증 로직(e.g., 이메일 형식 검증 메서드) 정도만 포함할 수 있습니다. 복잡한 비즈니스 규칙은 UseCase에 위치해야 합니다.

독립성: 데이터베이스(JPA, Room 등)나 네트워크(Serialization 관련) 어노테이션 등 외부 레이어와 관련된 어떤 의존성도 가져서는 안 됩니다.

// Domain Layer
package com.example.domain.model

data class Product(
    val id: String,
    val name: String,
    val price: Double,
    val description: String?,
    val stock: Int
) {
    // 간단한 비즈니스 규칙 포함 가능 (예: 재고 확인)
    fun isInStock(): Boolean = stock > 0
}

결론:


Domain 레이어를 이 가이드라인에 따라 Repository 인터페이스, UseCase, Domain Model 중심으로 구성하고 Hilt를 이용해 의존성을 관리하면, 비즈니스 로직이 명확하게 분리되고, 외부 변화에 강하며, 테스트하기 쉬운 애플리케이션 구조를 만들 수 있습니다. 이는 애플리케이션의 유지보수성과 확장성을 크게 향상시킵니다. 인터페이스 기반 설계와 @Binds 활용은 코드의 유연성과 테스트 용이성을 더욱 높여줍니다.