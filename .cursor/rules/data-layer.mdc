---
description: 
globs: 
alwaysApply: true
---
# 클린 아키텍처 Data Layer 가이드라인

클린 아키텍처의 Data Layer 구현을 위한 가이드라인입니다. 이 가이드라인은 데이터 처리, 저장, 네트워크 통신 등 Data Layer의 모든 측면을 다룹니다.

## 핵심 원칙

1. **관심사 분리 (Separation of Concerns)**
   - Data Layer는 데이터 처리와 관련된 모든 책임을 가짐
   - 데이터 소스(로컬, 원격)와 데이터 처리 로직을 분리
   - Domain Layer와의 명확한 경계 유지

2. **단일 책임 원칙 (Single Responsibility Principle)**
   - 각 클래스는 하나의 책임만 가짐
   - Repository는 데이터 조정만 담당
   - DataSource는 특정 데이터 소스와의 통신만 담당

3. **의존성 규칙 (Dependency Rule)**
   - Data Layer는 Domain Layer에 의존
   - Domain Layer는 Data Layer에 의존하지 않음
   - 외부 라이브러리 의존성은 Data Layer에 캡슐화

## 가이드라인 상세

### 1. Repository 패턴

#### Repository 인터페이스
```kotlin
interface UserRepository {
    suspend fun getUser(id: String): Result<User>
    suspend fun updateUser(user: User): Result<Unit>
    suspend fun deleteUser(id: String): Result<Unit>
}
```

#### Repository 구현
```kotlin
class UserRepositoryImpl @Inject constructor(
    private val remoteDataSource: UserRemoteDataSource,
    private val localDataSource: UserLocalDataSource,
    private val userMapper: UserMapper
) : UserRepository {
    override suspend fun getUser(id: String): Result<User> {
        return try {
            // 1. 로컬 데이터 확인
            val localUser = localDataSource.getUser(id)
            if (localUser != null) {
                return Result.success(userMapper.toDomain(localUser))
            }

            // 2. 원격 데이터 요청
            val remoteUser = remoteDataSource.getUser(id)
            if (remoteUser != null) {
                // 3. 로컬에 저장
                localDataSource.saveUser(remoteUser)
                return Result.success(userMapper.toDomain(remoteUser))
            }

            Result.failure(Exception("User not found"))
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### 2. DataSource

#### RemoteDataSource
```kotlin
interface UserRemoteDataSource {
    suspend fun getUser(id: String): UserDto?
    suspend fun updateUser(user: UserDto): Boolean
    suspend fun deleteUser(id: String): Boolean
}

class UserRemoteDataSourceImpl @Inject constructor(
    private val api: UserApi,
    private val networkHandler: NetworkHandler
) : UserRemoteDataSource {
    override suspend fun getUser(id: String): UserDto? {
        return if (networkHandler.isNetworkAvailable()) {
            try {
                api.getUser(id)
            } catch (e: Exception) {
                null
            }
        } else {
            null
        }
    }
}
```

#### LocalDataSource
```kotlin
interface UserLocalDataSource {
    suspend fun getUser(id: String): UserEntity?
    suspend fun saveUser(user: UserEntity)
    suspend fun deleteUser(id: String)
}

@Singleton
class UserLocalDataSourceImpl @Inject constructor(
    private val userDao: UserDao
) : UserLocalDataSource {
    override suspend fun getUser(id: String): UserEntity? {
        return userDao.getUserById(id)
    }

    override suspend fun saveUser(user: UserEntity) {
        userDao.insertUser(user)
    }
}
```

### 3. Mapper

#### Entity/DTO to Domain Mapper
```kotlin
class UserMapper @Inject constructor() {
    fun toDomain(entity: UserEntity): User {
        return User(
            id = entity.id,
            name = entity.name,
            email = entity.email
        )
    }

    fun toEntity(user: User): UserEntity {
        return UserEntity(
            id = user.id,
            name = user.name,
            email = user.email
        )
    }

    fun toDto(user: User): UserDto {
        return UserDto(
            id = user.id,
            name = user.name,
            email = user.email
        )
    }
}
```

### 4. 데이터 모델

#### Entity (Room)
```kotlin
@Entity(tableName = "users")
data class UserEntity(
    @PrimaryKey
    val id: String,
    val name: String,
    val email: String,
    val createdAt: Long = System.currentTimeMillis()
)
```

#### DTO (API)
```kotlin
data class UserDto(
    val id: String,
    val name: String,
    val email: String
)
```

### 5. 의존성 주입

#### Hilt Module
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object DataModule {
    @Provides
    @Singleton
    fun provideUserRepository(
        remoteDataSource: UserRemoteDataSource,
        localDataSource: UserLocalDataSource,
        userMapper: UserMapper
    ): UserRepository {
        return UserRepositoryImpl(remoteDataSource, localDataSource, userMapper)
    }

    @Provides
    @Singleton
    fun provideUserRemoteDataSource(
        api: UserApi,
        networkHandler: NetworkHandler
    ): UserRemoteDataSource {
        return UserRemoteDataSourceImpl(api, networkHandler)
    }

    @Provides
    @Singleton
    fun provideUserLocalDataSource(
        userDao: UserDao
    ): UserLocalDataSource {
        return UserLocalDataSourceImpl(userDao)
    }
}
```

### 6. 에러 처리

#### Result 래퍼
```kotlin
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    data class Error(val exception: Exception) : Result<Nothing>()
    object Loading : Result<Nothing>()
}
```

#### 커스텀 예외
```kotlin
sealed class DataException : Exception() {
    data class NetworkError(override val message: String) : DataException()
    data class DatabaseError(override val message: String) : DataException()
    data class DataNotFound(override val message: String) : DataException()
}
```

### 7. 테스트

#### Repository 테스트
```kotlin
@RunWith(MockitoJUnitRunner::class)
class UserRepositoryTest {
    @Mock
    private lateinit var remoteDataSource: UserRemoteDataSource
    
    @Mock
    private lateinit var localDataSource: UserLocalDataSource
    
    @Mock
    private lateinit var userMapper: UserMapper
    
    private lateinit var repository: UserRepository

    @Before
    fun setup() {
        repository = UserRepositoryImpl(remoteDataSource, localDataSource, userMapper)
    }

    @Test
    fun `getUser returns success when data exists in local`() = runTest {
        // Given
        val userId = "123"
        val userEntity = UserEntity(userId, "Test", "test@test.com")
        val user = User(userId, "Test", "test@test.com")
        
        whenever(localDataSource.getUser(userId)).thenReturn(userEntity)
        whenever(userMapper.toDomain(userEntity)).thenReturn(user)

        // When
        val result = repository.getUser(userId)

        // Then
        assertTrue(result.isSuccess)
        assertEquals(user, result.getOrNull())
    }
}
```

## 결론

이 가이드라인은 클린 아키텍처의 Data Layer 구현을 위한 기본적인 패턴과 원칙을 제시합니다. 이를 통해:

1. **테스트 용이성**: 각 컴포넌트가 명확히 분리되어 있어 단위 테스트가 용이
2. **유지보수성**: 관심사가 잘 분리되어 있어 코드 변경이 용이
3. **확장성**: 새로운 데이터 소스나 처리 로직을 쉽게 추가 가능
4. **재사용성**: 공통 컴포넌트를 쉽게 재사용 가능

이러한 이점을 얻을 수 있습니다. 실제 구현 시에는 프로젝트의 요구사항과 규모에 따라 이 가이드라인을 적절히 조정하여 사용하시기 바랍니다.