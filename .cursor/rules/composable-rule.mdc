---
description: 
globs: 
alwaysApply: true
---
# 클린 아키텍처 기반 Jetpack Compose UI 코드 가이드라인

클린 아키텍처 원칙을 따르면서 Jetpack Compose로 UI를 효과적으로 구축하기 위한 코드 가이드라인입니다. 이 가이드라인은 특정 UI에 국한되지 않고 범용적으로 적용될 수 있도록 작성되었습니다.

## 핵심 원칙

1. **관심사 분리 (Separation of Concerns)**
   - UI 레이어는 오직 UI 렌더링과 사용자 입력 처리에만 집중
   - 비즈니스 로직, 데이터 처리 로직은 포함하지 않음

2. **단방향 데이터 흐름 (Unidirectional Data Flow - UDF)**
   - 상태(State)는 상위(ViewModel)에서 하위(Composable)로 흐름
   - 이벤트(Event)는 하위에서 상위로 전달

3. **상태(State)는 위로 끌어올리기 (State Hoisting)**
   - 재사용성과 테스트 용이성을 위해 상태는 가능한 한 Composable 외부(주로 ViewModel)에서 관리

4. **의존성 규칙 (Dependency Rule)**
   - UI 레이어는 ViewModel(Presentation 레이어)에만 의존
   - UseCase나 Data 레이어에 직접 의존하지 않음

## 가이드라인 상세

### 1. Composable 함수 설계

#### 작고 집중된 함수
- 각 Composable 함수는 단일 책임 원칙(SRP)에 따라 하나의 특정 UI 요소나 작은 UI 그룹을 렌더링하는 데 집중
- 복잡한 화면은 여러 개의 작은 Composable 함수로 분리

#### 컴포저블 분리 패턴
화면 단위의 컴포저블은 다음과 같이 두 개의 컴포저블로 분리:

1. **Screen 컴포저블** (예: MyScreen)
   - ViewModel 주입 및 상태 관리 담당
   - hiltViewModel()을 통한 ViewModel 주입
   - StateFlow를 State로 변환
   - 이벤트 핸들러와 ViewModel 함수 연결
   - Contents 컴포저블 호출

2. **Contents 컴포저블** (예: MyScreenContents)
   - 실제 UI 렌더링 담당
   - UI 상태를 파라미터로 받음
   - 모든 이벤트 핸들러를 파라미터로 받음
   - ViewModel에 직접적인 의존성이 없음
   - Preview 지원

예시:
```kotlin
@Composable
fun MyScreen(
    modifier: Modifier = Modifier,
    viewModel: MyViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    
    MyScreenContents(
        uiState = uiState,
        onRefresh = viewModel::refresh,
        onItemClick = { id -> viewModel.onItemClicked(id) },
        modifier = modifier
    )
}

@Composable
fun MyScreenContents(
    uiState: MyScreenUiState,
    onRefresh: () -> Unit,
    onItemClick: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    // UI 렌더링
}

@Preview
@Composable
fun MyScreenContentsPreview() {
    MyScreenContents(
        uiState = MyScreenUiState(...),
        onRefresh = {},
        onItemClick = {},
    )
}
```

#### 상태 비소유 (Stateless) 선호
- 가능하면 Composable 함수는 자체적으로 상태를 가지지 않도록 설계
- 필요한 데이터는 파라미터로 전달받고, 사용자 이벤트는 람다(lambda) 콜백 함수를 통해 상위로 전달 ((event: T) -> Unit 형태)

#### 파라미터 순서
표준적인 파라미터 순서:
1. 필수 데이터 (UI 표시에 필요한 값)
2. modifier: Modifier (항상 기본값 Modifier 제공)
3. 선택적 상태 값 (드물게 사용, 주로 Hoisting)
4. 이벤트 핸들러 람다 (onEventName: (...) -> Unit)

### 2. 상태 관리 (State Management)

#### ViewModel 중심
- 화면(Screen) 단위의 UI 상태는 ViewModel에서 StateFlow 또는 State로 관리
- UI 상태를 나타내는 전용 데이터 클래스(e.g., MyScreenUiState)를 정의

#### UI 상태 클래스 정의
```kotlin
data class ExampleUiState(
    val isLoading: Boolean = false,
    val items: List<Item> = emptyList(),
    val errorMessage: String? = null
)
```

#### 상태 수집 (Collecting State)
- Composable에서는 ViewModel의 StateFlow를 collectAsStateWithLifecycle() 또는 collectAsState() 확장 함수를 사용하여 State<T>로 변환하고 관찰
- collectAsStateWithLifecycle 사용을 권장하여 Lifecycle을 고려한 안전한 수집을 보장

### 3. ViewModel과의 상호작용

#### 이벤트 처리
```kotlin
@Composable
fun MyScreen(viewModel: MyViewModel = hiltViewModel()) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()

    MyScreenContent(
        uiState = uiState,
        onItemClick = { itemId -> viewModel.onItemClicked(itemId) },
        onRefresh = { viewModel.refreshData() }
    )
}
```

#### 사이드 이펙트 관리
- Composable 함수 내에서 직접 네트워크 요청, 데이터베이스 접근 등의 사이드 이펙트를 발생시키지 않음
- 이러한 작업은 ViewModel에서 처리
- Composable 내의 사이드 이펙트는 LaunchedEffect, DisposableEffect 등을 사용하여 Compose의 생명주기에 맞게 관리
- UI 자체와 관련된 효과(애니메이션 시작, 스크롤 위치 변경 등)에만 사용

### 4. 테스트

#### Preview 활용
```kotlin
@Preview(showBackground = true)
@Composable
fun MyScreenContentsEmptyPreview() {
    MyScreenContents(
        uiState = MyScreenUiState(
            isLoading = false,
            items = emptyList()
        ),
        onRefresh = {},
        onItemClick = {}
    )
}

@Preview(showBackground = true)
@Composable
fun MyScreenContentsLoadingPreview() {
    MyScreenContents(
        uiState = MyScreenUiState(
            isLoading = true,
            items = emptyList()
        ),
        onRefresh = {},
        onItemClick = {}
    )
}
```

#### 프리뷰 작성 가이드라인
- Screen 컴포저블이 아닌 Contents 컴포저블에 대해 프리뷰 작성
- 다양한 상태 조합에 대한 프리뷰 제공 (빈 상태, 로딩 상태, 데이터 있는 상태, 에러 상태 등)
- 모든 이벤트 핸들러에 대해 빈 람다({}) 제공
- 실제 데이터와 유사한 더미 데이터 사용

### 5. 명명 규칙 (Naming Convention)

- **Composable 함수**: 파스칼 케이스(PascalCase) 명사 형태 (e.g., UserProfileCard, SubmitButton)
- **UI 상태 클래스**: ScreenNameUiState 또는 FeatureUiState (e.g., LoginUiState)
- **이벤트 핸들러 람다**: on + 동사 형태 (e.g., onLoginClick, onValueChange)

## 결론

이 가이드라인은 클린 아키텍처의 원칙을 Jetpack Compose UI 개발에 적용하여, 테스트 가능하고, 유지보수하기 쉬우며, 재사용성 높은 UI 코드를 작성하는 데 도움을 줄 것입니다. 핵심은 UI 레이어를 최대한 '단순하게(Dumb)' 유지하고, 상태 관리와 비즈니스 로직 처리는 ViewModel 및 하위 레이어에 위임하는 것입니다.