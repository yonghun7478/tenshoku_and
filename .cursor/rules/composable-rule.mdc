---
description: 컴포저블, ui 코드를 생성할때 참고할 내용
globs: 
alwaysApply: false
---
클린 아키텍처 기반 Jetpack Compose UI 코드 가이드라인 (네비게이션 제외)
클린 아키텍처 원칙을 따르면서 Jetpack Compose로 UI를 효과적으로 구축하기 위한 코드 가이드라인입니다. 이 가이드라인은 특정 UI에 국한되지 않고 범용적으로 적용될 수 있도록 작성되었습니다.

핵심 원칙:

관심사 분리 (Separation of Concerns): UI 레이어는 오직 UI 렌더링과 사용자 입력 처리에만 집중합니다. 비즈니스 로직, 데이터 처리 로직은 포함하지 않습니다.

단방향 데이터 흐름 (Unidirectional Data Flow - UDF): 상태(State)는 상위(ViewModel)에서 하위(Composable)로 흐르고, 이벤트(Event)는 하위에서 상위로 전달됩니다.

상태(State)는 위로 끌어올리기 (State Hoisting): 재사용성과 테스트 용이성을 위해 상태는 가능한 한 Composable 외부(주로 ViewModel)에서 관리합니다.

의존성 규칙 (Dependency Rule): UI 레이어는 ViewModel(Presentation 레이어)에만 의존하며, UseCase나 Data 레이어에 직접 의존하지 않습니다.

가이드라인 상세:

1. Composable 함수 설계:

작고 집중된 함수: 각 Composable 함수는 단일 책임 원칙(SRP)에 따라 하나의 특정 UI 요소나 작은 UI 그룹을 렌더링하는 데 집중합니다. 복잡한 화면은 여러 개의 작은 Composable 함수로 분리합니다.

컴포저블 분리 패턴: 화면 단위의 컴포저블은 다음과 같이 두 개의 컴포저블로 분리합니다:

1) Screen 컴포저블 (예: MyScreen):
   - ViewModel 주입 및 상태 관리 담당
   - hiltViewModel()을 통한 ViewModel 주입
   - StateFlow를 State로 변환
   - 이벤트 핸들러와 ViewModel 함수 연결
   - Contents 컴포저블 호출

2) Contents 컴포저블 (예: MyScreenContents):
   - 실제 UI 렌더링 담당
   - UI 상태를 파라미터로 받음
   - 모든 이벤트 핸들러를 파라미터로 받음
   - ViewModel에 직접적인 의존성이 없음
   - Preview 지원

예시:
```kotlin
@Composable
fun MyScreen(
    modifier: Modifier = Modifier,
    viewModel: MyViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    
    MyScreenContents(
        uiState = uiState,
        onRefresh = viewModel::refresh,
        onItemClick = { id -> viewModel.onItemClicked(id) },
        modifier = modifier
    )
}

@Composable
fun MyScreenContents(
    uiState: MyScreenUiState,
    onRefresh: () -> Unit,
    onItemClick: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    // UI 렌더링
}

@Preview
@Composable
fun MyScreenContentsPreview() {
    MyScreenContents(
        uiState = MyScreenUiState(...),
        onRefresh = {},
        onItemClick = {},
    )
}
```

상태 비소유 (Stateless) 선호: 가능하면 Composable 함수는 자체적으로 상태를 가지지 않도록 설계합니다. 필요한 데이터는 파라미터로 전달받고, 사용자 이벤트는 람다(lambda) 콜백 함수를 통해 상위로 전달합니다 ((event: T) -> Unit 형태).

예시: 버튼 클릭 이벤트는 onClick: () -> Unit 파라미터로 받습니다.

파라미터 순서: 표준적인 파라미터 순서를 따릅니다:

필수 데이터 (UI 표시에 필요한 값)

modifier: Modifier (항상 기본값 Modifier 제공)

선택적 상태 값 (드물게 사용, 주로 Hoisting)

이벤트 핸들러 람다 (onEventName: (...) -> Unit)

Modifier 파라미터: Composable 함수의 유연성과 재사용성을 위해 modifier: Modifier 파라미터를 항상 포함하고, 이를 가장 바깥쪽 레이아웃에 적용합니다. 외부에서 레이아웃, 패딩 등을 제어할 수 있게 합니다.

Preview 활용: @Preview 어노테이션을 적극적으로 사용하여 각 Composable의 시각적 결과와 다양한 상태를 빠르게 확인하고 개발합니다.

2. 상태 관리 (State Management):

ViewModel 중심: 화면(Screen) 단위의 UI 상태는 ViewModel에서 StateFlow 또는 State 로 관리합니다. UI 상태를 나타내는 전용 데이터 클래스(e.g., MyScreenUiState)를 정의하는 것이 좋습니다.

UI 상태 클래스 정의: ViewModel이 노출하는 UI 상태는 화면 표시에 필요한 모든 데이터를 포함하는 불변(immutable) 데이터 클래스로 정의합니다. 로딩 상태, 데이터 목록, 오류 메시지 등을 포함할 수 있습니다.

data class ExampleUiState(
    val isLoading: Boolean = false,
    val items: List<Item> = emptyList(),
    val errorMessage: String? = null
)

상태 수집 (Collecting State): Composable에서는 ViewModel의 StateFlow를 collectAsStateWithLifecycle() (라이브러리 추가 필요) 또는 collectAsState() 확장 함수를 사용하여 State<T> 로 변환하고 관찰합니다. collectAsStateWithLifecycle 사용을 권장하여 Lifecycle을 고려한 안전한 수집을 보장합니다.

상태는 아래로, 이벤트는 위로: ViewModel에서 관찰한 State<T> 의 값을 하위 Composable 함수들에게 필요한 데이터 형태로 분해하여 전달합니다. 사용자 입력(클릭, 텍스트 변경 등)은 람다 콜백을 통해 ViewModel의 함수를 호출하는 방식으로 상위로 전달합니다.

3. ViewModel과의 상호작용:

이벤트 처리: 사용자 상호작용(버튼 클릭, 입력 등)은 Composable 함수 내에서 직접 로직을 처리하는 대신, ViewModel의 특정 함수를 호출하는 람다를 실행하도록 구현합니다.

// Screen Composable
@Composable
fun MyScreen(viewModel: MyViewModel = hiltViewModel()) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()

    MyScreenContent(
        uiState = uiState,
        onItemClick = { itemId -> viewModel.onItemClicked(itemId) },
        onRefresh = { viewModel.refreshData() }
    )
}

// Content Composable (Stateless)
@Composable
fun MyScreenContent(
    uiState: ExampleUiState,
    onItemClick: (String) -> Unit,
    onRefresh: () -> Unit,
    modifier: Modifier = Modifier
) {
    // ... UI rendering using uiState ...
    Button(onClick = onRefresh) { /* ... */ }
    // ... List rendering ...
    // ItemComposable(item = item, onClick = { onItemClick(item.id) })
}

사이드 이펙트 관리: Composable 함수 내에서 직접 네트워크 요청, 데이터베이스 접근 등의 사이드 이펙트를 발생시키지 않습니다. 이러한 작업은 ViewModel에서 처리되어야 합니다. Composable 내의 사이드 이펙트는 LaunchedEffect, DisposableEffect 등을 사용하여 Compose의 생명주기에 맞게 관리하되, 이는 주로 UI 자체와 관련된 효과(애니메이션 시작, 스크롤 위치 변경 등)에 사용하며, 비즈니스 로직 관련 사이드 이펙트는 ViewModel에 위임합니다.

4. 테스트:

Preview 활용: @Preview를 통해 다양한 상태의 Composable을 시각적으로 테스트합니다.

프리뷰 작성 가이드라인:
- Screen 컴포저블이 아닌 Contents 컴포저블에 대해 프리뷰 작성
- 다양한 상태 조합에 대한 프리뷰 제공 (빈 상태, 로딩 상태, 데이터 있는 상태, 에러 상태 등)
- 모든 이벤트 핸들러에 대해 빈 람다({}) 제공
- 실제 데이터와 유사한 더미 데이터 사용

예시:
```kotlin
@Preview(showBackground = true)
@Composable
fun MyScreenContentsEmptyPreview() {
    MyScreenContents(
        uiState = MyScreenUiState(
            isLoading = false,
            items = emptyList()
        ),
        onRefresh = {},
        onItemClick = {}
    )
}

@Preview(showBackground = true)
@Composable
fun MyScreenContentsLoadingPreview() {
    MyScreenContents(
        uiState = MyScreenUiState(
            isLoading = true,
            items = emptyList()
        ),
        onRefresh = {},
        onItemClick = {}
    )
}
```

UI 테스트: ComposeTestRule을 사용하여 특정 Composable 또는 전체 화면의 동작(UI 요소 존재 여부, 상태 변화에 따른 UI 변경, 이벤트 핸들러 호출 등)을 검증합니다. 테스트 시에는 실제 ViewModel 대신 Mock 또는 Fake ViewModel을 주입하여 UI 로직만 격리하여 테스트합니다.

ViewModel 테스트: ViewModel은 UI와 분리되어 있으므로 일반적인 유닛 테스트(Unit Test)로 로직을 검증합니다.

5. 명명 규칙 (Naming Convention):

Composable 함수: 파스칼 케이스(PascalCase) 명사 형태로 작성합니다 (e.g., UserProfileCard, SubmitButton).

UI 상태 클래스: ScreenNameUiState 또는 FeatureUiState 와 같이 명명합니다 (e.g., LoginUiState).

이벤트 핸들러 람다: on + 동사 형태로 명명합니다 (e.g., onLoginClick, onValueChange).

6. 결론:

이 가이드라인은 클린 아키텍처의 원칙을 Jetpack Compose UI 개발에 적용하여, 테스트 가능하고, 유지보수하기 쉬우며, 재사용성 높은 UI 코드를 작성하는 데 도움을 줄 것입니다. 핵심은 UI 레이어를 최대한 '단순하게(Dumb)' 유지하고, 상태 관리와 비즈니스 로직 처리는 ViewModel 및 하위 레이어에 위임하는 것입니다.