---
description: 
globs: 
alwaysApply: true
---
클린 아키텍처 기반 ViewModel 코드 가이드라인클린 아키텍처에서 ViewModel(Presentation 레이어)은 UI에 표시할 상태를 관리하고, UI 이벤트를 처리하여 비즈니스 로직(UseCase)을 실행하는 역할을 담당합니다. 다음은 일관성 있고 유지보수 가능한 ViewModel을 작성하기 위한 공통 가이드라인입니다.핵심 원칙:UI 상태 소유: ViewModel은 UI가 관찰하고 렌더링하는 데 필요한 상태(State)를 소유하고 노출합니다.비즈니스 로직 위임: ViewModel은 직접 비즈니스 로직을 수행하지 않고, UseCase(Domain 레이어)를 호출하여 로직 실행을 위임합니다.Android 프레임워크 의존성 최소화: ViewModel은 안드로이드 프레임워크(Context, View 등)에 직접 의존하지 않아야 합니다. (AndroidViewModel 사용은 필요한 경우로 제한). 이는 테스트 용이성을 높입니다.생명주기 인식: ViewModel은 자체 생명주기(viewModelScope)를 가지며, 이를 활용하여 비동기 작업을 관리합니다.가이드라인 상세:1. 책임 및 역할:상태 관리: UI에 필요한 데이터를 가공하여 UI 상태(UiState) 형태로 만들어 StateFlow 또는 State를 통해 노출합니다.이벤트 처리: UI로부터 사용자 입력(클릭, 텍스트 변경 등) 이벤트를 받아 처리합니다.UseCase 호출: 처리된 UI 이벤트를 바탕으로 적절한 UseCase를 실행합니다. ViewModel은 필요한 UseCase들을 Hilt를 통해 주입받아 사용합니다.결과 반영: UseCase 실행 결과를 받아 UiState를 업데이트하여 UI에 반영합니다.해야 할 일:UI 상태 홀딩 및 노출UI 이벤트 수신 및 UseCase 호출viewModelScope를 이용한 코루틴 관리하지 말아야 할 일:안드로이드 프레임워크 클래스 직접 참조 (Context, View, Resource ID 등) - 필요한 경우 DI를 통해 추상화된 형태로 주입받습니다.데이터 레이어(Repository) 직접 접근 (UseCase를 통해 접근)복잡한 비즈니스 로직 직접 구현 (UseCase에 위임)네비게이션 로직 직접 포함 (이벤트 발행 후 Activity/Fragment에서 처리)2. 상태 관리 (State Management):UI 상태 클래스 정의: 화면에 필요한 모든 데이터를 포함하는 불변(immutable) data class를 정의합니다. 로딩 상태, 데이터, 오류 메시지 등을 명시적으로 포함합니다.// 예시: 로그인 화면 UI 상태
data class LoginUiState(
    val isLoading: Boolean = false,
    val email: String = "",
    val showPasswordError: Boolean = false,
    val loginSuccess: Boolean = false, // 단발성 이벤트는 다른 방식으로 처리하는 것이 더 좋을 수 있음
    val generalErrorMessage: String? = null
)
StateFlow 사용: UI 상태를 노출할 때는 StateFlow를 사용하는 것을 권장합니다. 초기값을 가져야 하며, 마지막 상태를 저장하고 있다가 새로운 구독자에게 즉시 발행합니다.private val _uiState = MutableStateFlow(LoginUiState()) // 초기 상태 설정
val uiState: StateFlow<LoginUiState> = _uiState.asStateFlow() // 읽기 전용으로 노출
상태 업데이트: ViewModel 내부에서 상태를 변경할 때는 _uiState.update { ... } 또는 _uiState.value = ... 를 사용합니다. update 함수는 스레드 안전하게 상태를 업데이트하는 데 도움이 됩니다.// 로딩 상태 업데이트 예시
_uiState.update { currentState ->
    currentState.copy(isLoading = true)
}
단발성 이벤트 처리: 스낵바 표시, 토스트 메시지, 화면 이동과 같은 단발성 이벤트는 StateFlow에 상태로 포함시키기보다 SharedFlow 또는 별도의 채널(Channel)을 사용하여 처리하는 것을 고려합니다. (UI 레이어에서 이벤트를 한 번만 소비하도록)3. 이벤트 처리:Public 함수: UI에서 호출할 수 있는 Public 함수를 통해 이벤트를 받습니다. 함수 이름은 처리하는 작업을 명확하게 나타내도록 짓습니다 (e.g., onLoginButtonClicked(), onEmailChanged(newEmail: String)).// HiltViewModel 어노테이션 추가
@HiltViewModel
class LoginViewModel @Inject constructor(
    private val loginUseCase: LoginUseCase // UseCase 주입
    // ... 다른 UseCase나 SavedStateHandle 등 주입 가능
) : ViewModel() {

    private val _uiState = MutableStateFlow(LoginUiState())
    val uiState: StateFlow<LoginUiState> = _uiState.asStateFlow()

    fun onLoginButtonClicked() {
        if (_uiState.value.isLoading) return // 로딩 중 중복 처리 방지

        _uiState.update { it.copy(isLoading = true, generalErrorMessage = null) }

        viewModelScope.launch {
            val email = _uiState.value.email
            // 비밀번호는 상태로 관리하지 않는 것이 보안상 좋을 수 있음 (별도 관리)
            val password = // ... (Get password securely)

            try {
                // 주입받은 UseCase 실행
                val result = loginUseCase(email, password)
                if (result.isSuccess) {
                    _uiState.update { it.copy(isLoading = false, loginSuccess = true) }
                    // loginSuccess 같은 상태 대신 SharedFlow 이벤트 발행 고려
                } else {
                    _uiState.update { it.copy(isLoading = false, generalErrorMessage = "로그인 실패") }
                }
            } catch (e: Exception) {
                _uiState.update { it.copy(isLoading = false, generalErrorMessage = "오류 발생: ${e.message}") }
            }
        }
    }

    fun onEmailChanged(newEmail: String) {
        _uiState.update { it.copy(email = newEmail) }
    }
}
4. 의존성 주입 (Dependency Injection):Hilt 사용: Hilt를 사용하여 ViewModel의 의존성을 관리합니다. ViewModel 클래스에는 @HiltViewModel 어노테이션을 붙여야 합니다.생성자 주입: 필요한 UseCase나 SavedStateHandle 등의 의존성은 생성자를 통해 주입받습니다. ViewModel 생성자에 @Inject 어노테이션을 사용합니다.@HiltViewModel
class ExampleViewModel @Inject constructor(
    private val getUserUseCase: GetUserUseCase, // UseCase 주입
    private val updateSettingsUseCase: UpdateSettingsUseCase, // 다른 UseCase 주입
    private val savedStateHandle: SavedStateHandle // 필요한 경우
) : ViewModel() {
    // ... ViewModel 로직 ...
}
인터페이스 의존: UseCase를 주입받을 때, 가능하다면 구체 클래스 대신 인터페이스 타입으로 주입받는 것이 좋습니다. (Domain 레이어 가이드라인의 UseCase 인터페이스 패턴 참고) 이는 결합도를 낮추고 테스트 용이성을 높입니다.5. 코루틴 관리:viewModelScope 사용: ViewModel 내에서 비동기 작업을 실행할 때는 반드시 viewModelScope를 사용합니다. viewModelScope는 ViewModel이 파괴될 때 자동으로 코루틴을 취소하여 메모리 누수를 방지합니다.viewModelScope.launch {
    // 비동기 작업 수행 (e.g., UseCase 호출)
}

Structured Concurrency: viewModelScope 내에서 여러 launch 또는 async를 사용할 때 부모-자식 관계를 활용하여 작업을 구조화하고 에러 처리를 용이하게 합니다.6. 테스트:유닛 테스트: ViewModel은 안드로이드 프레임워크 의존성이 거의 없으므로 JUnit과 Mocking 프레임워크(e.g., Mockito, Mockk)를 사용하여 쉽게 유닛 테스트를 작성할 수 있습니다. 주입받는 UseCase 등 외부 의존성은 Mock 객체로 대체합니다.상태 변화 검증: 테스트에서는 특정 이벤트를 발생시킨 후 ViewModel의 uiState가 예상대로 변경되었는지 검증합니다. StateFlow 테스트에는 Turbine과 같은 라이브러리가 유용할 수 있습니다.7. 명명 규칙 (Naming Convention):ViewModel 클래스: FeatureNameViewModel 또는 ScreenNameViewModel (e.g., LoginViewModel, UserProfileViewModel).UI 상태 변수: uiState, state 등 일관된 이름을 사용합니다. Private MutableStateFlow는 _uiState와 같이 밑줄 접두사를 사용합니다.이벤트 처리 함수: onEventName, handleAction 등 명확한 동사 형태로 작성합니다 (e.g., onLoginClick, loadUserProfile).결론:이 가이드라인을 따르면 클린 아키텍처 원칙에 부합하는, 테스트하기 쉽고, 이해하기 쉬우며, 유지보수하기 좋은 ViewModel을 작성할 수 있습니다. ViewModel의 역할을 명확히 하고, Hilt를 통해 UseCase를 주입받아 상태 관리와 이벤트 처리를 일관된 방식으로 구현하는 것이 중요합니다.