---
description: 
globs: 
alwaysApply: true
---
# 클린 아키텍처 의존성 주입 가이드라인

클린 아키텍처에서 의존성 주입(Dependency Injection) 구현을 위한 가이드라인입니다. 이 가이드라인은 Hilt를 사용한 의존성 주입 설정과 모듈 구성 방법을 다룹니다.

## 핵심 원칙

1. **모듈화 (Modularity)**
   - 각 레이어별로 독립적인 DI 모듈 구성
   - 기능별로 모듈 분리
   - 테스트를 위한 모듈 분리

2. **스코프 관리 (Scope Management)**
   - 적절한 스코프 사용 (Singleton, Activity, Fragment 등)
   - 메모리 누수 방지
   - 생명주기 고려

3. **의존성 규칙 (Dependency Rule)**
   - 내부 레이어는 외부 레이어에 의존하지 않음
   - 인터페이스에 의존
   - 구현체는 DI를 통해 주입

## 가이드라인 상세

### 1. 애플리케이션 설정

#### Application 클래스
```kotlin
@HiltAndroidApp
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        // 애플리케이션 초기화 로직
    }
}
```

#### AndroidManifest.xml
```xml
<application
    android:name=".MyApplication"
    ...>
    <!-- 애플리케이션 설정 -->
</application>
```

### 2. 레이어별 모듈

#### Domain 모듈
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object DomainModule {
    @Provides
    @Singleton
    fun provideGetUserUseCase(
        userRepository: UserRepository
    ): GetUserUseCase {
        return GetUserUseCase(userRepository)
    }

    @Provides
    @Singleton
    fun provideUpdateUserUseCase(
        userRepository: UserRepository
    ): UpdateUserUseCase {
        return UpdateUserUseCase(userRepository)
    }
}
```

#### Data 모듈
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object DataModule {
    @Provides
    @Singleton
    fun provideUserRepository(
        remoteDataSource: UserRemoteDataSource,
        localDataSource: UserLocalDataSource,
        userMapper: UserMapper
    ): UserRepository {
        return UserRepositoryImpl(remoteDataSource, localDataSource, userMapper)
    }

    @Provides
    @Singleton
    fun provideUserRemoteDataSource(
        api: UserApi,
        networkHandler: NetworkHandler
    ): UserRemoteDataSource {
        return UserRemoteDataSourceImpl(api, networkHandler)
    }

    @Provides
    @Singleton
    fun provideUserLocalDataSource(
        userDao: UserDao
    ): UserLocalDataSource {
        return UserLocalDataSourceImpl(userDao)
    }
}
```

#### Presentation 모듈
```kotlin
@Module
@InstallIn(ViewModelComponent::class)
object PresentationModule {
    @Provides
    fun provideUserViewModel(
        getUserUseCase: GetUserUseCase,
        updateUserUseCase: UpdateUserUseCase
    ): UserViewModel {
        return UserViewModel(getUserUseCase, updateUserUseCase)
    }
}
```

### 3. 네트워크 모듈

#### Retrofit 설정
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    @Provides
    @Singleton
    fun provideOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            .addInterceptor(HttpLoggingInterceptor().apply {
                level = HttpLoggingInterceptor.Level.BODY
            })
            .build()
    }

    @Provides
    @Singleton
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .baseUrl(BuildConfig.API_BASE_URL)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }

    @Provides
    @Singleton
    fun provideUserApi(retrofit: Retrofit): UserApi {
        return retrofit.create(UserApi::class.java)
    }
}
```

### 4. 데이터베이스 모듈

#### Room 설정
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    @Provides
    @Singleton
    fun provideAppDatabase(
        @ApplicationContext context: Context
    ): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            "app_database"
        ).build()
    }

    @Provides
    @Singleton
    fun provideUserDao(database: AppDatabase): UserDao {
        return database.userDao()
    }
}
```

### 5. 테스트 모듈

#### 테스트용 모듈
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object TestModule {
    @Provides
    @Singleton
    fun provideFakeUserRepository(): UserRepository {
        return FakeUserRepository()
    }

    @Provides
    @Singleton
    fun provideFakeUserApi(): UserApi {
        return FakeUserApi()
    }
}
```

### 6. 컴포넌트 스코프

#### 스코프 정의
```kotlin
@Scope
@Retention(Retention.RUNTIME)
annotation class UserScope

@Scope
@Retention(Retention.RUNTIME)
annotation class AuthScope
```

#### 스코프 사용
```kotlin
@Module
@InstallIn(UserComponent::class)
object UserModule {
    @Provides
    @UserScope
    fun provideUserManager(
        userRepository: UserRepository
    ): UserManager {
        return UserManagerImpl(userRepository)
    }
}
```

## 결론

이 가이드라인은 클린 아키텍처에서 의존성 주입을 구현하기 위한 기본적인 패턴과 원칙을 제시합니다. 이를 통해:

1. **모듈화**: 명확한 책임 분리와 모듈화
2. **테스트 용이성**: 테스트를 위한 의존성 주입 구성
3. **유지보수성**: 명확한 의존성 구조로 인한 쉬운 유지보수
4. **확장성**: 새로운 기능 추가가 용이한 구조

이러한 이점을 얻을 수 있습니다. 실제 구현 시에는 프로젝트의 요구사항과 규모에 따라 이 가이드라인을 적절히 조정하여 사용하시기 바랍니다.

