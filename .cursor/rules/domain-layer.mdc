---
description: 
globs: 
alwaysApply: true
---
# 클린 아키텍처 Domain 레이어 가이드라인

Domain 레이어는 클린 아키텍처의 핵심으로, 애플리케이션의 순수한 비즈니스 로직과 규칙을 담고 있습니다. 이 레이어는 다른 어떤 레이어(UI, Data, Framework)에도 의존하지 않아야 하며, 애플리케이션의 가장 안정적인 부분이 됩니다.

## 핵심 원칙

1. **독립성 (Independence)**
   - Domain 레이어는 UI, Data, Infrastructure 레이어로부터 완전히 독립적
   - 외부 변화에 영향을 받지 않아야 함
   - 순수한 비즈니스 로직만 포함

2. **비즈니스 로직 중심**
   - 애플리케이션의 핵심 비즈니스 규칙, 정책, 절차를 포함
   - 복잡한 비즈니스 로직을 UseCase로 캡슐화
   - 도메인 모델을 통한 비즈니스 개념 표현

3. **플랫폼 독립성**
   - 특정 프레임워크나 라이브러리에 대한 의존성 없음
   - 순수한 Kotlin/Java 코드로 작성
   - 안드로이드 SDK 의존성 제거

## 가이드라인 상세

### 1. Repository 인터페이스

#### 인터페이스 정의
```kotlin
interface UserRepository {
    suspend fun getUser(userId: String): User?
    suspend fun getAllUsers(): List<User>
    suspend fun saveUser(user: User): Result<Unit>
    suspend fun deleteUser(userId: String): Result<Unit>
}
```

#### 주요 특징
- **인터페이스 우선**: 데이터 접근을 위한 명세로 인터페이스를 먼저 정의
- **구현 분리**: 실제 구현체는 Data 레이어에 위치
- **추상화**: 데이터 소스에 대한 접근 방법을 추상화
- **도메인 모델 사용**: Data 레이어의 DTO나 DB 모델을 직접 반환하지 않음

#### Hilt 바인딩
```kotlin
@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {
    @Binds
    @Singleton
    abstract fun bindUserRepository(
        userRepositoryImpl: UserRepositoryImpl
    ): UserRepository
}
```

### 2. UseCase (Interactor)

#### 기본 구조
```kotlin
// 인터페이스 (선택적)
interface GetUserProfileUseCase {
    suspend operator fun invoke(userId: String): Result<UserProfile>
}

// 구현체
class GetUserProfileUseCaseImpl @Inject constructor(
    private val userRepository: UserRepository,
    private val preferenceRepository: PreferenceRepository
) : GetUserProfileUseCase {
    override suspend operator fun invoke(userId: String): Result<UserProfile> {
        val user = userRepository.getUser(userId) ?: return Result.failure(UserNotFoundException())
        val preferences = preferenceRepository.getPreferencesForUser(userId)
        return Result.success(UserProfile(user, preferences))
    }
}
```

#### 주요 특징
- **단일 책임**: 각 UseCase는 하나의 명확한 비즈니스 작업만 수행
- **의존성 주입**: Repository 인터페이스를 생성자 주입으로 받음
- **실행 메서드**: `operator fun invoke()`를 통해 UseCase를 함수처럼 호출
- **결과 처리**: Result 래퍼를 사용하여 성공/실패 처리

#### Hilt 모듈
```kotlin
@Module
@InstallIn(ViewModelComponent::class)
abstract class UseCaseModule {
    @Binds
    abstract fun bindGetUserProfileUseCase(
        getUserProfileUseCaseImpl: GetUserProfileUseCaseImpl
    ): GetUserProfileUseCase
}
```

### 3. Domain Model (Entity)

#### 기본 구조
```kotlin
data class Product(
    val id: String,
    val name: String,
    val price: Double,
    val description: String?,
    val stock: Int
) {
    fun isInStock(): Boolean = stock > 0
    fun calculateTotalPrice(quantity: Int): Double = price * quantity
}
```

#### 주요 특징
- **순수성**: 데이터와 필수적인 검증 로직만 포함
- **독립성**: 외부 레이어의 어노테이션이나 의존성 없음
- **불변성**: 가능한 한 불변(immutable) 객체로 설계
- **도메인 규칙**: 간단한 비즈니스 규칙은 도메인 모델에 포함 가능

### 4. 도메인 서비스

#### 검증 서비스
```kotlin
class UserValidationService @Inject constructor() {
    fun validateEmail(email: String): Boolean {
        return android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches()
    }

    fun validatePassword(password: String): Boolean {
        return password.length >= 8 && 
               password.any { it.isDigit() } &&
               password.any { it.isUpperCase() }
    }
}
```

#### 계산 서비스
```kotlin
class PriceCalculationService @Inject constructor() {
    fun calculateDiscount(price: Double, discountRate: Double): Double {
        return price * (1 - discountRate)
    }

    fun calculateTax(price: Double, taxRate: Double): Double {
        return price * taxRate
    }
}
```

### 5. 도메인 예외

#### 커스텀 예외
```kotlin
sealed class DomainException : Exception() {
    data class UserNotFound(override val message: String) : DomainException()
    data class InvalidInput(override val message: String) : DomainException()
    data class NetworkError(override val message: String) : DomainException()
}
```

### 6. 테스트

#### UseCase 테스트
```kotlin
class GetUserUseCaseTest {
    private lateinit var getUserUseCase: GetUserUseCase
    private lateinit var userRepository: FakeUserRepository

    @Before
    fun setup() {
        userRepository = FakeUserRepository()
        getUserUseCase = GetUserUseCase(userRepository)
    }

    @Test
    fun `when user exists, return success`() = runTest {
        // Given
        val userId = "test-user"
        val expectedUser = User(userId, "Test User")
        userRepository.addUser(expectedUser)

        // When
        val result = getUserUseCase(userId)

        // Then
        assertTrue(result.isSuccess)
        assertEquals(expectedUser, result.getOrNull())
    }
}
```

## 결론

이 가이드라인을 따르면 다음과 같은 이점을 얻을 수 있습니다:

1. **비즈니스 로직 격리**: 핵심 비즈니스 로직이 외부 의존성으로부터 격리됨
2. **테스트 용이성**: 순수한 비즈니스 로직으로 인한 쉬운 테스트
3. **유지보수성**: 명확한 책임 분리로 인한 쉬운 유지보수
4. **재사용성**: 도메인 모델과 UseCase의 재사용 가능

실제 구현 시에는 프로젝트의 요구사항과 규모에 따라 이 가이드라인을 적절히 조정하여 사용하시기 바랍니다.


